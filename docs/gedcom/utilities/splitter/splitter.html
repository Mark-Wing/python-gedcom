<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>gedcom.utilities.splitter.splitter API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gedcom.utilities.splitter.splitter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import re as regex
import sys, getopt
from pathlib import Path

from gedcom.element.family import FamilyElement
from gedcom.element.individual import IndividualElement
from gedcom.element.individual import NotAnActualIndividualError
from gedcom.element.object import ObjectElement
from gedcom.element.source import SourceElement
from gedcom.element.repository import RepositoryElement
from gedcom.parser import Parser

import gedcom.tags

class Splitter(Parser):
        
    def __init__(self):
        super().__init__()

    def split_gedcom(self, ancestor, include_inlaws=True, callback=None):
        &#34;&#34;&#34; Creates a GEDCOM for the a portion of the tree based on the ancester, their
        descendants, their descendants&#39; spouses and their descendants&#39; parents (assuming they
        are not a spouse). If include_inlaws is True, it also includes the parents of spouses and 
        descendants&#39; parents. 
        
        :type ancestor: Element

        :type include_inlaws: bool

        :type callback: function(str message, progress int, progress_total int

        :rtype: str
        &#34;&#34;&#34;
        
        #validate ancestor
        if not isinstance(ancestor, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % gedcom.tags.GEDCOM_TAG_INDIVIDUAL
            )
        
        if ancestor.get_pointer() not in self.get_element_dictionary():
            return &#39;Ancestor not in tree&#39;
        
        #initialize arrays used when determining what to include
        individual_ids = []
        family_ids = []
        source_ids = []
        repository_ids = []
        object_ids = []
        spouses = []
        
        root_elements = len(self.get_root_child_elements())
        people_in_tree = 0
        
        # get descendants, their family elements and the pointers for the their spouses
        count = 0
        for element in self.get_root_child_elements():
            if isinstance(element, IndividualElement):
                people_in_tree += 1
                if self.find_path_to_ancestor(element, ancestor, parent_type=&#34;All&#34;) != None:
                    individual_ids.append(element.get_pointer())
                    
                    for family_element in self.get_families(element):
                        family_ids.append(family_element.get_pointer())
                        
                        for spouse_element in self.get_family_members(family_element, &#34;PARENTS&#34;):
                            if element.get_pointer() != spouse_element.get_pointer():
                                spouses.append(spouse_element.get_pointer())                        
                
            count += 1
            self.__update_progress(&#34;Gathering descendants&#34;, count, root_elements, callback)
        
        # get spouses, their family elements and optionally their parents
        count = 0
        for element in self.get_root_child_elements():
            if isinstance(element, IndividualElement):
                if element.get_pointer() in spouses:
                    if element.get_pointer() not in individual_ids: 
                        individual_ids.append(element.get_pointer())
                    
                    for family_element in self.get_families(element, gedcom.tags.GEDCOM_TAG_FAMILY_CHILD):
                        family_ids.append(family_element.get_pointer())
                        
                        if include_inlaws:
                            for parent_element in self.get_parents(element):
                                if parent_element.get_pointer() not in individual_ids:
                                    individual_ids.append(parent_element.get_pointer())

            count += 1
            self.__update_progress(&#34;Gathering spouses of descendants&#34;, count, root_elements, callback)

        # remove people not in tree
        people_to_remove = people_in_tree - len(individual_ids)        
        count = 0
        x = 0
        while x &lt; len(self.get_root_child_elements()):
            element = self.get_root_child_elements()[x]
            if isinstance(element, IndividualElement):
                if element.get_pointer() not in individual_ids:
                    self.__remove_root_child_element(element)
                    count += 1
                    self.__update_progress(&#34;Removing non-family members&#34;, count, people_to_remove, callback)
                else:
                    x += 1
            elif isinstance(element, FamilyElement):
                if element.get_pointer() not in family_ids:
                    self.__remove_root_child_element(element)
                else:
                    x += 1
            else:
                x += 1

        # determine which sources are still needed
        root_elements = len(self.get_root_child_elements())
        count = 0
        sources_in_tree = 0
        for element in self.get_root_child_elements():
            if isinstance(element, IndividualElement):
                for child in element.get_child_elements():
                    for childOfChild in child.get_child_elements():
                        if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                            if childOfChild.get_value() not in source_ids:
                                source_ids.append(childOfChild.get_value())

            elif isinstance(element, FamilyElement):
                for child in element.get_child_elements():
                    for childOfChild in child.get_child_elements():
                        if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                            if childOfChild.get_value() not in source_ids:
                                source_ids.append(childOfChild.get_value())
                                
            elif isinstance(element, SourceElement):
                sources_in_tree += 1

            count += 1
            self.__update_progress(&#34;Gathering sources&#34;, count, root_elements, callback)
                
        # remove sources that are not needed
        sources_to_remove = sources_in_tree - len(source_ids)
        count = 0
        x = 0
        while x &lt; len(self.get_root_child_elements()):
            element = self.get_root_child_elements()[x]
            if isinstance(element, SourceElement):
                if element.get_pointer() not in source_ids:
                    self.__remove_root_child_element(element)
                    count += 1
                    self.__update_progress(&#34;Removing unused sources&#34;, count, sources_to_remove, callback)
                else:
                    x = x + 1
            else:
                x = x + 1

        # determine which repositories are still needed
        root_elements = len(self.get_root_child_elements())
        count = 0
        repositories_in_tree = 0
        for element in self.get_root_child_elements():
            if isinstance(element, SourceElement):
                repository = element.get_repository()
                if repository != &#34;&#34; and element.get_repository() not in repository_ids:
                    repository_ids.append(element.get_repository())
            elif isinstance(element, RepositoryElement):
                repositories_in_tree += 1
            
            count += 1
            self.__update_progress(&#34;Gathering repositories&#34;, count, root_elements, callback)
                
        # remove repositories that are not needed
        repositories_to_remove = repositories_in_tree - len(repository_ids)
        count = 0
        x = 0
        while x &lt; len(self.get_root_child_elements()):
            element = self.get_root_child_elements()[x]
            if isinstance(element, RepositoryElement):
                if element.get_pointer() not in repository_ids:
                    self.__remove_root_child_element(element)
                    count += 1
                    self.__update_progress(&#34;Removing unused repositories&#34;, count, repositories_to_remove, callback)
                else:
                    x = x + 1
            else:
                x = x + 1

        # determine which media objects are still needed
        root_elements = len(self.get_root_child_elements())
        objects_in_tree = 0
        count = 0
        for element in self.get_root_child_elements():
            if isinstance(element, IndividualElement):
                for child in element.get_child_elements():
                    if child.get_tag() == &#39;OBJE&#39;:
                        if child.get_value() not in object_ids:
                            object_ids.append(childOfChild.get_value())

                    else:
                        for childOfChild in child.get_child_elements():
                            if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                                for obj in childOfChild.get_objects():
                                    if obj.get_value() not in object_ids:
                                        object_ids.append(obj.get_value())

            elif isinstance(element, ObjectElement):
                objects_in_tree += 1

            count += 1
            self.__update_progress(&#34;Gathering media&#34;, count, root_elements, callback)
            
        # remove objects that are not needed
        objects_to_remove = objects_in_tree - len(object_ids)
        count = 0
        x = 0        
        while x &lt; len(self.get_root_child_elements()):
            element = self.get_root_child_elements()[x]
            if isinstance(element, ObjectElement):
                if element.get_pointer() not in object_ids:
                    self.__remove_root_child_element(element)
                    count += 1    
                    self.__update_progress(&#34;Removing unused media&#34;, count, objects_to_remove, callback)
                else:
                    x = x + 1
            else:
                x = x + 1
 
    def write_file(self, file_name, callback=None):
        &#34;&#34;&#34;Writes tree in output file

        :type file_name: str
        
        :type callback: function(message as str, count as int, total as int)
        &#34;&#34;&#34;        
        root_elements = len(self.get_root_child_elements())
        count = 0
        
        f_out = open(file_name , &#39;w&#39;, encoding=&#39;utf-8&#39;, newline=&#39;&#39;)
        
        for element in self.get_root_child_elements():
            f_out.write(element.to_gedcom_string(True))
            count += 1
            self.__update_progress(&#34;Writing file&#34;, count, root_elements, callback)
        f_out.close()      
           
    def __update_progress(self, message, count, total, callback):
        &#34;&#34;&#34;if there is a callback function, calls the functions&#34;&#34;&#34;
        if callback != None:
            callback(message, count, total)
                
    def __remove_root_child_element(self, element):
        &#34;&#34;&#34;Removes child element from list of root elements                 
        
        :type element: Element
        &#34;&#34;&#34;
        self.get_root_element().remove_child_element(element.get_pointer())

# functions for support running from command line 
def print_usage_message():

    print(&#39;usage: python splitter.py -i &lt;gedcom-input-file&gt; [-h | -b &lt;year-of-birth&gt; | -d &lt;year-of-death&gt; | -g &lt;given-name&gt; | -l &lt;last-name&gt; | -o &lt;gedcom-output-file&gt; | -n] &#39;)
    print(&#39;Options and arguments (and corresponding environment variables):&#39;)
    print(&#39;-b : root person\&#39;s year of birth&#39;)
    print(&#39;-d : root person\&#39;s year of death&#39;)
    print(&#39;-g : part of all of the root person\&#39;s given name&#39;)
    print(&#39;-h : print this help message and exit&#39;)
    print(&#39;-i : file name of the source GEDCOM file&#39;)
    print(&#39;-l : part of all of the root person\&#39;s last name&#39;)
    print(&#39;-n : exclude father-in-law and mother-in-law of descendants&#39;)
    print(&#39;-o : file name of output GEDCOM file; if not included, adds &#34;_split&#34; to the input file name&#39;)
    print(&#39;-s : does not enforce strict parsing of GEDCOM file&#39;)

def build_criteria(criteria, field, value):

    if value != &#34;&#34;:
        if criteria != &#34;&#34;:
            criteria += &#34;:&#34;

        criteria += field + &#34;=&#34; + value
    
    return criteria

def progress_status(message, progress, progress_total):

    barLength = 30 # Modify this to change the length of the progress bar
    #status = &#34;&#34;
    #if isinstance(progress, int):
    #    progress = float(progress)

    if progress == 1:
        print()
        
    percent = round(progress / progress_total, 3)

    block = int(round(barLength * percent))
    #percent = round(progress*100, 3)
    
    text = &#34;\r{0}: [{1}] {2}/{3}                  &#34;.format( message, &#34;#&#34;*block + &#34;-&#34;*(barLength-block), progress, progress_total)
    sys.stdout.write(text)
    sys.stdout.flush()

        
def main(argv):
   
    input_file = &#39;&#39;
    output_file = &#39;&#39;
    include_inlaws = True
    birth_year = &#34;&#34;
    death_year = &#34;&#34;
    given_name = &#34;&#34;
    last_name = &#34;&#34;
    strict = True
   
    try:
        opts, args = getopt.getopt(argv,&#34;b:d:g:h:i:l:n:o:s&#34;)
   
        for opt, arg in opts:
            if opt == &#39;-h&#39;:
                print_usage_message()
                sys.exit()
            elif opt in (&#34;-b&#34;):
                birth_year = arg
            elif opt in (&#34;-d&#34;):
                death_year = arg
            elif opt in (&#34;-i&#34;):
                input_file = arg
            elif opt in (&#34;-g&#34;):
                given_name = arg
            elif opt in (&#34;-l&#34;):
                last_name = arg
            elif opt in (&#34;-n&#34;):
                include_inlaws = False
            elif opt in (&#34;-o&#34;):
                output_file = arg
            elif opt in (&#34;-s&#34;):
                strict = False
                
        if not Path(input_file).is_file():
            print(&#34;Input file is not a valid file&#34;)
            print_usage_message()
            sys.exit()

        if output_file == &#34;&#34;:
            output_file = str(Path(input_file).parent)  + &#34;/&#34; + str(Path(input_file).stem) \
                            + &#34;_split&#34; + str(Path(input_file).suffix)
        elif not Path(input_file).is_file():
            print(&#34;Output file is not a valid file&#34;)
            print_usage_message()
            sys.exit()
        
        criteria = &#34;&#34;
        
        criteria = build_criteria(criteria, &#39;given_name&#39;, given_name)
        criteria = build_criteria(criteria, &#39;surname&#39;, last_name)
        criteria = build_criteria(criteria, &#39;birth&#39;, birth_year)
        criteria = build_criteria(criteria, &#39;death&#39;, death_year)

        if criteria == &#34;&#34;:
            print(&#39;The root ancestor must be identied by at least one of the following fields:&#39;)
            print(&#39;* birth year&#39;)
            print(&#39;* death year&#39;)
            print(&#39;* given_name&#39;)
            print(&#39;* last name&#39;)
            print_usage_message()
            sys.exit()
            
        parser = Splitter()
        parser.parse_file(input_file, strict=strict, callback=progress_status)
        
        ancestor = parser.find_person(criteria)
        
        if ancestor == &#34;&#34;:
            print(&#34;No ancestor was found&#34;)
        else:
            parser.split_gedcom(ancestor, include_inlaws=include_inlaws, callback=progress_status)
            parser.write_file(output_file, callback=progress_status)
            print(&#34;\nSplit complete&#34;)
      
    except getopt.GetoptError:
        print_usage_message()
   
if __name__ == &#34;__main__&#34;:
    main(sys.argv[1:])    
    
    
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gedcom.utilities.splitter.splitter.build_criteria"><code class="name flex">
<span>def <span class="ident">build_criteria</span></span>(<span>criteria, field, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_criteria(criteria, field, value):

    if value != &#34;&#34;:
        if criteria != &#34;&#34;:
            criteria += &#34;:&#34;

        criteria += field + &#34;=&#34; + value
    
    return criteria</code></pre>
</details>
</dd>
<dt id="gedcom.utilities.splitter.splitter.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>argv)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(argv):
   
    input_file = &#39;&#39;
    output_file = &#39;&#39;
    include_inlaws = True
    birth_year = &#34;&#34;
    death_year = &#34;&#34;
    given_name = &#34;&#34;
    last_name = &#34;&#34;
    strict = True
   
    try:
        opts, args = getopt.getopt(argv,&#34;b:d:g:h:i:l:n:o:s&#34;)
   
        for opt, arg in opts:
            if opt == &#39;-h&#39;:
                print_usage_message()
                sys.exit()
            elif opt in (&#34;-b&#34;):
                birth_year = arg
            elif opt in (&#34;-d&#34;):
                death_year = arg
            elif opt in (&#34;-i&#34;):
                input_file = arg
            elif opt in (&#34;-g&#34;):
                given_name = arg
            elif opt in (&#34;-l&#34;):
                last_name = arg
            elif opt in (&#34;-n&#34;):
                include_inlaws = False
            elif opt in (&#34;-o&#34;):
                output_file = arg
            elif opt in (&#34;-s&#34;):
                strict = False
                
        if not Path(input_file).is_file():
            print(&#34;Input file is not a valid file&#34;)
            print_usage_message()
            sys.exit()

        if output_file == &#34;&#34;:
            output_file = str(Path(input_file).parent)  + &#34;/&#34; + str(Path(input_file).stem) \
                            + &#34;_split&#34; + str(Path(input_file).suffix)
        elif not Path(input_file).is_file():
            print(&#34;Output file is not a valid file&#34;)
            print_usage_message()
            sys.exit()
        
        criteria = &#34;&#34;
        
        criteria = build_criteria(criteria, &#39;given_name&#39;, given_name)
        criteria = build_criteria(criteria, &#39;surname&#39;, last_name)
        criteria = build_criteria(criteria, &#39;birth&#39;, birth_year)
        criteria = build_criteria(criteria, &#39;death&#39;, death_year)

        if criteria == &#34;&#34;:
            print(&#39;The root ancestor must be identied by at least one of the following fields:&#39;)
            print(&#39;* birth year&#39;)
            print(&#39;* death year&#39;)
            print(&#39;* given_name&#39;)
            print(&#39;* last name&#39;)
            print_usage_message()
            sys.exit()
            
        parser = Splitter()
        parser.parse_file(input_file, strict=strict, callback=progress_status)
        
        ancestor = parser.find_person(criteria)
        
        if ancestor == &#34;&#34;:
            print(&#34;No ancestor was found&#34;)
        else:
            parser.split_gedcom(ancestor, include_inlaws=include_inlaws, callback=progress_status)
            parser.write_file(output_file, callback=progress_status)
            print(&#34;\nSplit complete&#34;)
      
    except getopt.GetoptError:
        print_usage_message()</code></pre>
</details>
</dd>
<dt id="gedcom.utilities.splitter.splitter.print_usage_message"><code class="name flex">
<span>def <span class="ident">print_usage_message</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_usage_message():

    print(&#39;usage: python splitter.py -i &lt;gedcom-input-file&gt; [-h | -b &lt;year-of-birth&gt; | -d &lt;year-of-death&gt; | -g &lt;given-name&gt; | -l &lt;last-name&gt; | -o &lt;gedcom-output-file&gt; | -n] &#39;)
    print(&#39;Options and arguments (and corresponding environment variables):&#39;)
    print(&#39;-b : root person\&#39;s year of birth&#39;)
    print(&#39;-d : root person\&#39;s year of death&#39;)
    print(&#39;-g : part of all of the root person\&#39;s given name&#39;)
    print(&#39;-h : print this help message and exit&#39;)
    print(&#39;-i : file name of the source GEDCOM file&#39;)
    print(&#39;-l : part of all of the root person\&#39;s last name&#39;)
    print(&#39;-n : exclude father-in-law and mother-in-law of descendants&#39;)
    print(&#39;-o : file name of output GEDCOM file; if not included, adds &#34;_split&#34; to the input file name&#39;)
    print(&#39;-s : does not enforce strict parsing of GEDCOM file&#39;)</code></pre>
</details>
</dd>
<dt id="gedcom.utilities.splitter.splitter.progress_status"><code class="name flex">
<span>def <span class="ident">progress_status</span></span>(<span>message, progress, progress_total)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def progress_status(message, progress, progress_total):

    barLength = 30 # Modify this to change the length of the progress bar
    #status = &#34;&#34;
    #if isinstance(progress, int):
    #    progress = float(progress)

    if progress == 1:
        print()
        
    percent = round(progress / progress_total, 3)

    block = int(round(barLength * percent))
    #percent = round(progress*100, 3)
    
    text = &#34;\r{0}: [{1}] {2}/{3}                  &#34;.format( message, &#34;#&#34;*block + &#34;-&#34;*(barLength-block), progress, progress_total)
    sys.stdout.write(text)
    sys.stdout.flush()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gedcom.utilities.splitter.splitter.Splitter"><code class="flex name class">
<span>class <span class="ident">Splitter</span></span>
</code></dt>
<dd>
<div class="desc"><p>Parses and manipulates GEDCOM 5.5 format data
For documentation of the GEDCOM 5.5 format, see: <a href="http://homepages.rootsweb.ancestry.com/~pmcbride/gedcom/55gctoc.htm">http://homepages.rootsweb.ancestry.com/~pmcbride/gedcom/55gctoc.htm</a>
This parser reads and parses a GEDCOM file.
Elements may be accessed via:</p>
<ul>
<li>
<p>a <code>list</code> through <code><a title="gedcom.parser.Parser.get_element_list" href="../../parser.html#gedcom.parser.Parser.get_element_list">Parser.get_element_list()</a></code></p>
</li>
<li>
<p>a <code>dict</code> through <code><a title="gedcom.parser.Parser.get_element_dictionary" href="../../parser.html#gedcom.parser.Parser.get_element_dictionary">Parser.get_element_dictionary()</a></code></p>
</li>
</ul>
<p>Initialize a GEDCOM data object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Splitter(Parser):
        
    def __init__(self):
        super().__init__()

    def split_gedcom(self, ancestor, include_inlaws=True, callback=None):
        &#34;&#34;&#34; Creates a GEDCOM for the a portion of the tree based on the ancester, their
        descendants, their descendants&#39; spouses and their descendants&#39; parents (assuming they
        are not a spouse). If include_inlaws is True, it also includes the parents of spouses and 
        descendants&#39; parents. 
        
        :type ancestor: Element

        :type include_inlaws: bool

        :type callback: function(str message, progress int, progress_total int

        :rtype: str
        &#34;&#34;&#34;
        
        #validate ancestor
        if not isinstance(ancestor, IndividualElement):
            raise NotAnActualIndividualError(
                &#34;Operation only valid for elements with %s tag&#34; % gedcom.tags.GEDCOM_TAG_INDIVIDUAL
            )
        
        if ancestor.get_pointer() not in self.get_element_dictionary():
            return &#39;Ancestor not in tree&#39;
        
        #initialize arrays used when determining what to include
        individual_ids = []
        family_ids = []
        source_ids = []
        repository_ids = []
        object_ids = []
        spouses = []
        
        root_elements = len(self.get_root_child_elements())
        people_in_tree = 0
        
        # get descendants, their family elements and the pointers for the their spouses
        count = 0
        for element in self.get_root_child_elements():
            if isinstance(element, IndividualElement):
                people_in_tree += 1
                if self.find_path_to_ancestor(element, ancestor, parent_type=&#34;All&#34;) != None:
                    individual_ids.append(element.get_pointer())
                    
                    for family_element in self.get_families(element):
                        family_ids.append(family_element.get_pointer())
                        
                        for spouse_element in self.get_family_members(family_element, &#34;PARENTS&#34;):
                            if element.get_pointer() != spouse_element.get_pointer():
                                spouses.append(spouse_element.get_pointer())                        
                
            count += 1
            self.__update_progress(&#34;Gathering descendants&#34;, count, root_elements, callback)
        
        # get spouses, their family elements and optionally their parents
        count = 0
        for element in self.get_root_child_elements():
            if isinstance(element, IndividualElement):
                if element.get_pointer() in spouses:
                    if element.get_pointer() not in individual_ids: 
                        individual_ids.append(element.get_pointer())
                    
                    for family_element in self.get_families(element, gedcom.tags.GEDCOM_TAG_FAMILY_CHILD):
                        family_ids.append(family_element.get_pointer())
                        
                        if include_inlaws:
                            for parent_element in self.get_parents(element):
                                if parent_element.get_pointer() not in individual_ids:
                                    individual_ids.append(parent_element.get_pointer())

            count += 1
            self.__update_progress(&#34;Gathering spouses of descendants&#34;, count, root_elements, callback)

        # remove people not in tree
        people_to_remove = people_in_tree - len(individual_ids)        
        count = 0
        x = 0
        while x &lt; len(self.get_root_child_elements()):
            element = self.get_root_child_elements()[x]
            if isinstance(element, IndividualElement):
                if element.get_pointer() not in individual_ids:
                    self.__remove_root_child_element(element)
                    count += 1
                    self.__update_progress(&#34;Removing non-family members&#34;, count, people_to_remove, callback)
                else:
                    x += 1
            elif isinstance(element, FamilyElement):
                if element.get_pointer() not in family_ids:
                    self.__remove_root_child_element(element)
                else:
                    x += 1
            else:
                x += 1

        # determine which sources are still needed
        root_elements = len(self.get_root_child_elements())
        count = 0
        sources_in_tree = 0
        for element in self.get_root_child_elements():
            if isinstance(element, IndividualElement):
                for child in element.get_child_elements():
                    for childOfChild in child.get_child_elements():
                        if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                            if childOfChild.get_value() not in source_ids:
                                source_ids.append(childOfChild.get_value())

            elif isinstance(element, FamilyElement):
                for child in element.get_child_elements():
                    for childOfChild in child.get_child_elements():
                        if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                            if childOfChild.get_value() not in source_ids:
                                source_ids.append(childOfChild.get_value())
                                
            elif isinstance(element, SourceElement):
                sources_in_tree += 1

            count += 1
            self.__update_progress(&#34;Gathering sources&#34;, count, root_elements, callback)
                
        # remove sources that are not needed
        sources_to_remove = sources_in_tree - len(source_ids)
        count = 0
        x = 0
        while x &lt; len(self.get_root_child_elements()):
            element = self.get_root_child_elements()[x]
            if isinstance(element, SourceElement):
                if element.get_pointer() not in source_ids:
                    self.__remove_root_child_element(element)
                    count += 1
                    self.__update_progress(&#34;Removing unused sources&#34;, count, sources_to_remove, callback)
                else:
                    x = x + 1
            else:
                x = x + 1

        # determine which repositories are still needed
        root_elements = len(self.get_root_child_elements())
        count = 0
        repositories_in_tree = 0
        for element in self.get_root_child_elements():
            if isinstance(element, SourceElement):
                repository = element.get_repository()
                if repository != &#34;&#34; and element.get_repository() not in repository_ids:
                    repository_ids.append(element.get_repository())
            elif isinstance(element, RepositoryElement):
                repositories_in_tree += 1
            
            count += 1
            self.__update_progress(&#34;Gathering repositories&#34;, count, root_elements, callback)
                
        # remove repositories that are not needed
        repositories_to_remove = repositories_in_tree - len(repository_ids)
        count = 0
        x = 0
        while x &lt; len(self.get_root_child_elements()):
            element = self.get_root_child_elements()[x]
            if isinstance(element, RepositoryElement):
                if element.get_pointer() not in repository_ids:
                    self.__remove_root_child_element(element)
                    count += 1
                    self.__update_progress(&#34;Removing unused repositories&#34;, count, repositories_to_remove, callback)
                else:
                    x = x + 1
            else:
                x = x + 1

        # determine which media objects are still needed
        root_elements = len(self.get_root_child_elements())
        objects_in_tree = 0
        count = 0
        for element in self.get_root_child_elements():
            if isinstance(element, IndividualElement):
                for child in element.get_child_elements():
                    if child.get_tag() == &#39;OBJE&#39;:
                        if child.get_value() not in object_ids:
                            object_ids.append(childOfChild.get_value())

                    else:
                        for childOfChild in child.get_child_elements():
                            if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                                for obj in childOfChild.get_objects():
                                    if obj.get_value() not in object_ids:
                                        object_ids.append(obj.get_value())

            elif isinstance(element, ObjectElement):
                objects_in_tree += 1

            count += 1
            self.__update_progress(&#34;Gathering media&#34;, count, root_elements, callback)
            
        # remove objects that are not needed
        objects_to_remove = objects_in_tree - len(object_ids)
        count = 0
        x = 0        
        while x &lt; len(self.get_root_child_elements()):
            element = self.get_root_child_elements()[x]
            if isinstance(element, ObjectElement):
                if element.get_pointer() not in object_ids:
                    self.__remove_root_child_element(element)
                    count += 1    
                    self.__update_progress(&#34;Removing unused media&#34;, count, objects_to_remove, callback)
                else:
                    x = x + 1
            else:
                x = x + 1
 
    def write_file(self, file_name, callback=None):
        &#34;&#34;&#34;Writes tree in output file

        :type file_name: str
        
        :type callback: function(message as str, count as int, total as int)
        &#34;&#34;&#34;        
        root_elements = len(self.get_root_child_elements())
        count = 0
        
        f_out = open(file_name , &#39;w&#39;, encoding=&#39;utf-8&#39;, newline=&#39;&#39;)
        
        for element in self.get_root_child_elements():
            f_out.write(element.to_gedcom_string(True))
            count += 1
            self.__update_progress(&#34;Writing file&#34;, count, root_elements, callback)
        f_out.close()      
           
    def __update_progress(self, message, count, total, callback):
        &#34;&#34;&#34;if there is a callback function, calls the functions&#34;&#34;&#34;
        if callback != None:
            callback(message, count, total)
                
    def __remove_root_child_element(self, element):
        &#34;&#34;&#34;Removes child element from list of root elements                 
        
        :type element: Element
        &#34;&#34;&#34;
        self.get_root_element().remove_child_element(element.get_pointer())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gedcom.parser.Parser" href="../../parser.html#gedcom.parser.Parser">Parser</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gedcom.utilities.splitter.splitter.Splitter.split_gedcom"><code class="name flex">
<span>def <span class="ident">split_gedcom</span></span>(<span>self, ancestor, include_inlaws=True, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a GEDCOM for the a portion of the tree based on the ancester, their
descendants, their descendants' spouses and their descendants' parents (assuming they
are not a spouse). If include_inlaws is True, it also includes the parents of spouses and
descendants' parents. </p>
<p>:type ancestor: Element</p>
<p>:type include_inlaws: bool</p>
<p>:type callback: function(str message, progress int, progress_total int</p>
<p>:rtype: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_gedcom(self, ancestor, include_inlaws=True, callback=None):
    &#34;&#34;&#34; Creates a GEDCOM for the a portion of the tree based on the ancester, their
    descendants, their descendants&#39; spouses and their descendants&#39; parents (assuming they
    are not a spouse). If include_inlaws is True, it also includes the parents of spouses and 
    descendants&#39; parents. 
    
    :type ancestor: Element

    :type include_inlaws: bool

    :type callback: function(str message, progress int, progress_total int

    :rtype: str
    &#34;&#34;&#34;
    
    #validate ancestor
    if not isinstance(ancestor, IndividualElement):
        raise NotAnActualIndividualError(
            &#34;Operation only valid for elements with %s tag&#34; % gedcom.tags.GEDCOM_TAG_INDIVIDUAL
        )
    
    if ancestor.get_pointer() not in self.get_element_dictionary():
        return &#39;Ancestor not in tree&#39;
    
    #initialize arrays used when determining what to include
    individual_ids = []
    family_ids = []
    source_ids = []
    repository_ids = []
    object_ids = []
    spouses = []
    
    root_elements = len(self.get_root_child_elements())
    people_in_tree = 0
    
    # get descendants, their family elements and the pointers for the their spouses
    count = 0
    for element in self.get_root_child_elements():
        if isinstance(element, IndividualElement):
            people_in_tree += 1
            if self.find_path_to_ancestor(element, ancestor, parent_type=&#34;All&#34;) != None:
                individual_ids.append(element.get_pointer())
                
                for family_element in self.get_families(element):
                    family_ids.append(family_element.get_pointer())
                    
                    for spouse_element in self.get_family_members(family_element, &#34;PARENTS&#34;):
                        if element.get_pointer() != spouse_element.get_pointer():
                            spouses.append(spouse_element.get_pointer())                        
            
        count += 1
        self.__update_progress(&#34;Gathering descendants&#34;, count, root_elements, callback)
    
    # get spouses, their family elements and optionally their parents
    count = 0
    for element in self.get_root_child_elements():
        if isinstance(element, IndividualElement):
            if element.get_pointer() in spouses:
                if element.get_pointer() not in individual_ids: 
                    individual_ids.append(element.get_pointer())
                
                for family_element in self.get_families(element, gedcom.tags.GEDCOM_TAG_FAMILY_CHILD):
                    family_ids.append(family_element.get_pointer())
                    
                    if include_inlaws:
                        for parent_element in self.get_parents(element):
                            if parent_element.get_pointer() not in individual_ids:
                                individual_ids.append(parent_element.get_pointer())

        count += 1
        self.__update_progress(&#34;Gathering spouses of descendants&#34;, count, root_elements, callback)

    # remove people not in tree
    people_to_remove = people_in_tree - len(individual_ids)        
    count = 0
    x = 0
    while x &lt; len(self.get_root_child_elements()):
        element = self.get_root_child_elements()[x]
        if isinstance(element, IndividualElement):
            if element.get_pointer() not in individual_ids:
                self.__remove_root_child_element(element)
                count += 1
                self.__update_progress(&#34;Removing non-family members&#34;, count, people_to_remove, callback)
            else:
                x += 1
        elif isinstance(element, FamilyElement):
            if element.get_pointer() not in family_ids:
                self.__remove_root_child_element(element)
            else:
                x += 1
        else:
            x += 1

    # determine which sources are still needed
    root_elements = len(self.get_root_child_elements())
    count = 0
    sources_in_tree = 0
    for element in self.get_root_child_elements():
        if isinstance(element, IndividualElement):
            for child in element.get_child_elements():
                for childOfChild in child.get_child_elements():
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                        if childOfChild.get_value() not in source_ids:
                            source_ids.append(childOfChild.get_value())

        elif isinstance(element, FamilyElement):
            for child in element.get_child_elements():
                for childOfChild in child.get_child_elements():
                    if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                        if childOfChild.get_value() not in source_ids:
                            source_ids.append(childOfChild.get_value())
                            
        elif isinstance(element, SourceElement):
            sources_in_tree += 1

        count += 1
        self.__update_progress(&#34;Gathering sources&#34;, count, root_elements, callback)
            
    # remove sources that are not needed
    sources_to_remove = sources_in_tree - len(source_ids)
    count = 0
    x = 0
    while x &lt; len(self.get_root_child_elements()):
        element = self.get_root_child_elements()[x]
        if isinstance(element, SourceElement):
            if element.get_pointer() not in source_ids:
                self.__remove_root_child_element(element)
                count += 1
                self.__update_progress(&#34;Removing unused sources&#34;, count, sources_to_remove, callback)
            else:
                x = x + 1
        else:
            x = x + 1

    # determine which repositories are still needed
    root_elements = len(self.get_root_child_elements())
    count = 0
    repositories_in_tree = 0
    for element in self.get_root_child_elements():
        if isinstance(element, SourceElement):
            repository = element.get_repository()
            if repository != &#34;&#34; and element.get_repository() not in repository_ids:
                repository_ids.append(element.get_repository())
        elif isinstance(element, RepositoryElement):
            repositories_in_tree += 1
        
        count += 1
        self.__update_progress(&#34;Gathering repositories&#34;, count, root_elements, callback)
            
    # remove repositories that are not needed
    repositories_to_remove = repositories_in_tree - len(repository_ids)
    count = 0
    x = 0
    while x &lt; len(self.get_root_child_elements()):
        element = self.get_root_child_elements()[x]
        if isinstance(element, RepositoryElement):
            if element.get_pointer() not in repository_ids:
                self.__remove_root_child_element(element)
                count += 1
                self.__update_progress(&#34;Removing unused repositories&#34;, count, repositories_to_remove, callback)
            else:
                x = x + 1
        else:
            x = x + 1

    # determine which media objects are still needed
    root_elements = len(self.get_root_child_elements())
    objects_in_tree = 0
    count = 0
    for element in self.get_root_child_elements():
        if isinstance(element, IndividualElement):
            for child in element.get_child_elements():
                if child.get_tag() == &#39;OBJE&#39;:
                    if child.get_value() not in object_ids:
                        object_ids.append(childOfChild.get_value())

                else:
                    for childOfChild in child.get_child_elements():
                        if childOfChild.get_tag() == gedcom.tags.GEDCOM_TAG_SOURCE:
                            for obj in childOfChild.get_objects():
                                if obj.get_value() not in object_ids:
                                    object_ids.append(obj.get_value())

        elif isinstance(element, ObjectElement):
            objects_in_tree += 1

        count += 1
        self.__update_progress(&#34;Gathering media&#34;, count, root_elements, callback)
        
    # remove objects that are not needed
    objects_to_remove = objects_in_tree - len(object_ids)
    count = 0
    x = 0        
    while x &lt; len(self.get_root_child_elements()):
        element = self.get_root_child_elements()[x]
        if isinstance(element, ObjectElement):
            if element.get_pointer() not in object_ids:
                self.__remove_root_child_element(element)
                count += 1    
                self.__update_progress(&#34;Removing unused media&#34;, count, objects_to_remove, callback)
            else:
                x = x + 1
        else:
            x = x + 1</code></pre>
</details>
</dd>
<dt id="gedcom.utilities.splitter.splitter.Splitter.write_file"><code class="name flex">
<span>def <span class="ident">write_file</span></span>(<span>self, file_name, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes tree in output file</p>
<p>:type file_name: str</p>
<p>:type callback: function(message as str, count as int, total as int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_file(self, file_name, callback=None):
    &#34;&#34;&#34;Writes tree in output file

    :type file_name: str
    
    :type callback: function(message as str, count as int, total as int)
    &#34;&#34;&#34;        
    root_elements = len(self.get_root_child_elements())
    count = 0
    
    f_out = open(file_name , &#39;w&#39;, encoding=&#39;utf-8&#39;, newline=&#39;&#39;)
    
    for element in self.get_root_child_elements():
        f_out.write(element.to_gedcom_string(True))
        count += 1
        self.__update_progress(&#34;Writing file&#34;, count, root_elements, callback)
    f_out.close()      </code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gedcom.parser.Parser" href="../../parser.html#gedcom.parser.Parser">Parser</a></b></code>:
<ul class="hlist">
<li><code><a title="gedcom.parser.Parser.find_all_paths_to_ancestor" href="../../parser.html#gedcom.parser.Parser.find_all_paths_to_ancestor">find_all_paths_to_ancestor</a></code></li>
<li><code><a title="gedcom.parser.Parser.find_path_to_ancestor" href="../../parser.html#gedcom.parser.Parser.find_path_to_ancestor">find_path_to_ancestor</a></code></li>
<li><code><a title="gedcom.parser.Parser.find_person" href="../../parser.html#gedcom.parser.Parser.find_person">find_person</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_ancestors" href="../../parser.html#gedcom.parser.Parser.get_ancestors">get_ancestors</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_children" href="../../parser.html#gedcom.parser.Parser.get_children">get_children</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_element_dictionary" href="../../parser.html#gedcom.parser.Parser.get_element_dictionary">get_element_dictionary</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_element_list" href="../../parser.html#gedcom.parser.Parser.get_element_list">get_element_list</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_families" href="../../parser.html#gedcom.parser.Parser.get_families">get_families</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_family" href="../../parser.html#gedcom.parser.Parser.get_family">get_family</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_family_members" href="../../parser.html#gedcom.parser.Parser.get_family_members">get_family_members</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_marriage_years" href="../../parser.html#gedcom.parser.Parser.get_marriage_years">get_marriage_years</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_marriages" href="../../parser.html#gedcom.parser.Parser.get_marriages">get_marriages</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_marriages_data" href="../../parser.html#gedcom.parser.Parser.get_marriages_data">get_marriages_data</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_parents" href="../../parser.html#gedcom.parser.Parser.get_parents">get_parents</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_root_child_elements" href="../../parser.html#gedcom.parser.Parser.get_root_child_elements">get_root_child_elements</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_root_element" href="../../parser.html#gedcom.parser.Parser.get_root_element">get_root_element</a></code></li>
<li><code><a title="gedcom.parser.Parser.get_spouses" href="../../parser.html#gedcom.parser.Parser.get_spouses">get_spouses</a></code></li>
<li><code><a title="gedcom.parser.Parser.invalidate_cache" href="../../parser.html#gedcom.parser.Parser.invalidate_cache">invalidate_cache</a></code></li>
<li><code><a title="gedcom.parser.Parser.marriage_range_match" href="../../parser.html#gedcom.parser.Parser.marriage_range_match">marriage_range_match</a></code></li>
<li><code><a title="gedcom.parser.Parser.marriage_year_match" href="../../parser.html#gedcom.parser.Parser.marriage_year_match">marriage_year_match</a></code></li>
<li><code><a title="gedcom.parser.Parser.parse" href="../../parser.html#gedcom.parser.Parser.parse">parse</a></code></li>
<li><code><a title="gedcom.parser.Parser.parse_file" href="../../parser.html#gedcom.parser.Parser.parse_file">parse_file</a></code></li>
<li><code><a title="gedcom.parser.Parser.print_gedcom" href="../../parser.html#gedcom.parser.Parser.print_gedcom">print_gedcom</a></code></li>
<li><code><a title="gedcom.parser.Parser.save_gedcom" href="../../parser.html#gedcom.parser.Parser.save_gedcom">save_gedcom</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gedcom.utilities.splitter" href="index.html">gedcom.utilities.splitter</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gedcom.utilities.splitter.splitter.build_criteria" href="#gedcom.utilities.splitter.splitter.build_criteria">build_criteria</a></code></li>
<li><code><a title="gedcom.utilities.splitter.splitter.main" href="#gedcom.utilities.splitter.splitter.main">main</a></code></li>
<li><code><a title="gedcom.utilities.splitter.splitter.print_usage_message" href="#gedcom.utilities.splitter.splitter.print_usage_message">print_usage_message</a></code></li>
<li><code><a title="gedcom.utilities.splitter.splitter.progress_status" href="#gedcom.utilities.splitter.splitter.progress_status">progress_status</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gedcom.utilities.splitter.splitter.Splitter" href="#gedcom.utilities.splitter.splitter.Splitter">Splitter</a></code></h4>
<ul class="">
<li><code><a title="gedcom.utilities.splitter.splitter.Splitter.split_gedcom" href="#gedcom.utilities.splitter.splitter.Splitter.split_gedcom">split_gedcom</a></code></li>
<li><code><a title="gedcom.utilities.splitter.splitter.Splitter.write_file" href="#gedcom.utilities.splitter.splitter.Splitter.write_file">write_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>